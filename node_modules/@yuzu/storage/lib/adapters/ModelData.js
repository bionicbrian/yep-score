import _ from "underscore";
import { autobind } from "core-decorators";
import { emitter } from "spak/decorators";
import { propertyOf, nullEmitter, beforeWrap } from "../utils";
import domainUpdate from "./domainUpdate";

const DEFAULT_SV_KEY = "_storeVal";

export default class ModelData {
    constructor(...storeVals) {
        this._storeVal = storeVals[0]; // First arg is the default storeValue.
        this._publish = _.isFunction(this._emitter) ? this._emitter() : nullEmitter(this);
        var listen = _.once(this._listen);
        this.on = beforeWrap(this.on, listen);
        this.once = beforeWrap(this.once, listen);
        this.onMatch = beforeWrap(this.onMatch, listen);
        this._createSVGettersFor(storeVals);
    }

    _createSVGettersFor(storeVals) {
        storeVals.forEach((sv) => {
            Object.defineProperty(this, `${sv.store.namespace}SV`, {
                get: () => sv,
                enumerable: true
            });
        });
    }

    get id() {
        return this._storeVal.key;
    }

    get parentId() {
        return this._storeVal.get("parentId");
    }

    get storeVal() {
        return this._storeVal;
    }

    // (data:Object) -> StoreItResult // storeValKey defaults to "_storeVal"
    // (storeValKey: string, data: Object) -> StoreItResult
    _update(...args) {
        var [svKey, data] = args.length === 2 ? args : [DEFAULT_SV_KEY, args[0]];
        return domainUpdate(this[svKey], data);
    }

    @autobind
    _listen() {
        this._storeVal.on("changed", this._handleSVChanged);
        this._storeVal.once("removed", this._handleSVRemoved);
    }

    @autobind
    _handleSVChanged(value) {
        var map = this._fieldsMap;
        var change = _.object(
            Object.keys(value)
                .filter(key => map.hasOwnProperty(key))
                .map(_.compose(field => [field.mdField, this[field.mdField]], propertyOf(map)))
        );
        if (Object.keys(change).length > 0) {
            this._publishChanged(change);
        }
    }

    _publishChanged(ev) {
        if (Object.keys(ev).length > 0) {
            this._publish("changed", ev);
        }
    }

    @autobind
    _handleSVRemoved() {
        this._storeVal.off("changed", this._handleSVChanged);
        this._publish("removed");
    }

    static get mappers() {
        return {
            schema(dataSchema, fieldMapper) {
                return {
                    schema: dataSchema,
                    mappings: fieldMapper(dataSchema)
                };
            },
            maps(...definitions) {
                return (schema) => definitions.reduce(
                    (mappings, mapper) => mappings.concat(mapper(schema)), []
                );
            },
            schemaFields(transform = _.identity) {
                return dataSchema => dataSchema.fields
                    .map(transform)
                    .filter(val => !!val)
                    .map(field => _.isString(field) ? [field, field] : field);
            },
            sameAsSV(...fields) {
                return () => fields.map(field => [field, field]);
            },
            mapToSV(...maps) {
                return () => maps;
            }
        };
    }

    // Decorator that takes a list of schema defns.
    // Creates a protected getter for the each schema provided.
    // Creates a protected getter of mapping from sv field name to md field plus what store value to fetch.
    // Each field in the field map will become a getter and setter.
    static mapping(...schemaDefns) {
        var schemas = _.object(
            schemaDefns.map(({ schema }) => [schema.namespace, schema])
        );
        var fields = _.object(
            _.flatten(schemaDefns.map(
                ({ schema, mappings }) => mappings.map(
                    ([mdField, svField]) => [svField, { svField, mdField, svKey: `${schema.namespace}SV` }]
                )
            ), true)
        );

        return (target) => {
            Object.defineProperty(target.prototype, "_schemas", {
                value: schemas
            });
            Object.defineProperty(target.prototype, "_fieldsMap", {
                value: fields
            });
            Object.defineProperty(target.prototype, "_mapOfSVtoMD", {
                value: _.object(Object.keys(fields).map(field => [field, fields[field].mdField]))
            });
            Object.keys(fields).forEach((svField) => {
                var field = fields[svField];
                if (field.mdField in target.prototype) {
                    return; // RETURN EARLY! If md already has prop do nothing.
                }
                Object.defineProperty(target.prototype, field.mdField, {
                    get() {
                        return this[field.svKey].get(svField);
                    },
                    set(val) {
                        return this._update(field.svKey, { [svField]: val });
                    },
                    enumerable: true
                });
            });
        };
    }

    static emitter(target) {
        emitter(["changed", "removed"])(target);
    }
}
