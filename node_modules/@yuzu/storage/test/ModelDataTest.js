import _ from "underscore";
import { makeEmitter } from "pubit-as-promised";
import ModelData from "../lib/adapters/ModelData";
var { schema, maps, schemaFields, sameAsSV, mapToSV } = ModelData.mappers;

function storeValStub(namespace, data) {
    var sv = {};
    sv.publish = makeEmitter(sv);
    sv.key = data.id;
    sv.data = data;
    sv.get = (prop) => data[prop];
    sv.set = (prop, val) => data[prop] = val;
    sv.store = { namespace };
    return sv;
}

var fooSchema = {
    namespace: "foo",
    key: "id",
    foreignKeys: ["parentId"],
    fields: ["title", "text", "colorAsHex",
             "limitNum", "size", "addedAt", "isActive"]
};

var bazSchema = {
    namespace: "baz",
    key: "id",
    foreignKeys: ["parentId"],
    fields: ["name", "size", "page"]
};

@ModelData.emitter
@ModelData.mapping(
    schema(fooSchema, maps(
        schemaFields(),
        sameAsSV("custom1", "custom2"),
        mapToSV(
            ["color", "colorAsHex"],
            ["limit", "limitNum"]
        )
    ))
)
class FooMD extends ModelData {
    get color() {
        return this._storeVal.get("colorAsHex");
    }
    get addedAt() {
        return new Date(this._storeVal.get("addedAt"));
    }
}

@ModelData.emitter
@ModelData.mapping(
    schema(fooSchema, maps(
        sameAsSV("title", "isActive"),
        mapToSV(["color", "colorAsHex"])
    )),
    schema(bazSchema, maps(
        schemaFields(),
        mapToSV(["bazId", "id"])
    ))
)
class FooAndBazMD extends ModelData {
    get color() {
        return this._storeVal.get("colorAsHex");
    }
}

function updateSv(sv, update) {
    _.extend(sv.data, update);
    sv.publish("changed", update);
}

describe("ModelData Adapter:", function () {
    describe("Creating ModelData with 1 store value", () => {
        beforeEach(() => {
            this.sv = storeValStub("foo", {
                id: "ABC",
                parentId: "123",
                title: "Intro to Foo",
                text: "Summary of foo",
                colorAsHex: "#FFFFFF",
                limitNum: 5,
                size: 200,
                addedAt: new Date("12/25/2010").toISOString(),
                isActive: false
            });
            this.md = new FooMD(this.sv);
        });

        it("should implement observable", () => {
            this.md.should.respondTo("on");
            this.md.should.respondTo("off");
            this.md.should.respondTo("once");
        });

        it("should expose the default store value as `storeVal`", () => {
            this.md.storeVal.should.equal(this.sv);
        });

        it("should create a getter for the store value using it's namespace `fooSV`", () => {
            this.md.fooSV.should.equal(this.sv);
        });

        it("should expose id and parentId", () => {
            this.md.id.should.equal("ABC");
            this.md.parentId.should.equal("123");
        });

        it("should have created properties", () => {
            this.md.should.have.property("title");
            this.md.should.have.property("text");
            this.md.should.have.property("size");
            this.md.should.have.property("isActive");
            this.md.should.have.property("custom1");
            this.md.should.have.property("custom2");
        });

        it("should have created properties with correct values", () => {
            this.md.title.should.equal("Intro to Foo");
            this.md.text.should.equal("Summary of foo");
            this.md.size.should.equal(200);
            this.md.isActive.should.equal(false);
        });

        it("should NOT have created properties for mapped field", () => {
            this.md.should.not.have.property("colorAsHex");
            this.md.should.not.have.property("limitNum");
        });

        describe("when a changed event is emitted", () => {
            beforeEach(() => {
                this.changedListener = sinon.stub();
            });

            describe("with sv props not mapped to md", () => {
                beforeEach(() => {
                    this.md.on("changed", this.changedListener);
                    updateSv(this.sv, {
                        amount: 100, food: "mexican", name: "bobby"
                    });
                });

                // Event sv event has 3 props, md event is never emitted
                // MD events only emit props that are in sv map or declared as props.
                // TODO Fix... new mapping api will give you event if field exists on any of the store vals.
                xit("should NOT call the changed listener", () => {
                    this.changedListener.should.not.have.been.called;
                });
            });

            describe("with 3 sv props that are mapped to md", () => {
                beforeEach(() => {
                    this.md.on("changed", this.changedListener);
                    updateSv(this.sv, {
                        colorAsHex: "#333333", isActive: true,
                        addedAt: new Date("7/3/1980").toISOString(),
                        baz: "yup", bar: "Roseanne"
                    });
                });

                // Event sv event has 3 props, md event only contains 1 prop
                // MD events only emit props that are in sv map or declared as props.
                it("should call changed listener with 3 new prop values", () => {
                    this.changedListener.should.have.been.called;
                    this.changedListener.should.have.been.calledWith(sinon.match(
                        ev => ev.should.eql(
                            { color: "#333333", isActive: true, addedAt: new Date("7/3/1980") }
                        )
                    ));
                });
            });
        });

        describe("when a removed event is emitted", () => {
            beforeEach(() => {
                this.removedListener = sinon.stub();
                this.md.on("removed", this.removedListener);
                this.sv.publish("removed");
            });

            it("should call removed listener", () => {
                this.removedListener.should.have.been.called;
            });
        });
    });

    describe("Creating ModelData with 2 store values", () => {
        beforeEach(() => {
            this.fooSV = storeValStub("foo", {
                id: "ABC",
                parentId: "123",
                title: "Intro to Foo",
                text: "Summary of foo",
                colorAsHex: "#FFFFFF",
                limitNum: 5,
                size: 100,
                addedAt: new Date("12/25/2010").toISOString(),
                isActive: false
            });
            this.bazSV = storeValStub("baz", {
                id: "DEF",
                parentId: "123",
                name: "Lenny",
                size: 200,
                page: "ii"
            });
            this.md = new FooAndBazMD(this.fooSV, this.bazSV);
        });

        it("should expose the default store value as `storeVal`", () => {
            this.md.storeVal.should.equal(this.fooSV);
        });

        it("should create a getter for both store values passed in", () => {
            this.md.fooSV.should.equal(this.fooSV);
            this.md.bazSV.should.equal(this.bazSV);
        });

        it("should expose id and parentId", () => {
            this.md.id.should.equal("ABC");
            this.md.parentId.should.equal("123");
        });

        it("should have created properties", () => {
            this.md.should.have.property("name");
            this.md.should.have.property("size");
            this.md.should.have.property("page");
            this.md.should.have.property("bazId");
            this.md.should.have.property("title");
            this.md.should.have.property("isActive");
        });

        it("should have created properties with correct values", () => {
            this.md.name.should.equal("Lenny");
            this.md.size.should.equal(200);
            this.md.page.should.equal("ii");
            this.md.bazId.should.equal("DEF");
            this.md.title.should.equal("Intro to Foo");
            this.md.isActive.should.equal(false);
        });

        it("should NOT have created properties for mapped field", () => {
            this.md.should.not.have.property("colorAsHex");
            this.md.should.not.have.property("limitNum");
        });

        describe("when a changed event is emitted on fooSV", () => {
            beforeEach(() => {
                this.changedListener = sinon.stub();
            });

            describe("with sv props not mapped to md (include prop from baz)", () => {
                beforeEach(() => {
                    this.md.on("changed", this.changedListener);
                    updateSv(this.fooSV, {
                        amount: 100, food: "mexican", name: "bobby"
                    });
                });

                // Event sv event has 3 props, md event is never emitted
                // MD events only emit props that are in sv map or declared as props.
                xit("should NOT call the changed listener", () => {
                    this.changedListener.should.not.have.been.called;
                });
            });

            describe("with 2 sv props that are mapped to md", () => {
                beforeEach(() => {
                    this.md.on("changed", this.changedListener);
                    updateSv(this.fooSV, {
                        colorAsHex: "#333333", isActive: true, baz: "yup", bar: "Roseanne"
                    });
                });

                // Event sv event has 3 props, md event only contains 1 prop
                // MD events only emit props that are in sv map or declared as props.
                it("should call changed listener with 3 new prop values", () => {
                    this.changedListener.should.have.been.called;
                    this.changedListener.should.have.been.calledWith(sinon.match(
                        ev => ev.should.eql(
                            { color: "#333333", isActive: true }
                        )
                    ));
                });
            });
        });
    });
});

