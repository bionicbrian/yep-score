import _ from "underscore";
import Storeit from "storeit";
import { App } from "@yuzu/yep-app";
import domainUpdate from "../lib/adapters/domainUpdate";

const NONE = Storeit.Action.none;
const ADDED = Storeit.Action.added;
const MODIFIED = Storeit.Action.modified;

const ORIGINAL_DATA = { name: "bob", color: "red", size: 100 };
const CHANGE_DATA = { name: "bob", color: "blue", size: 100 };

function stubStoreVal(details) {
    return {
        set: sinon.spy(() => details),
        toObject: sinon.spy(() => {
            return _.extend({}, ORIGINAL_DATA);
        })
    };
}

describe("domainUpdate:", function () {
    beforeEach(() => {
        this._appPublish = sinon.spy(App.events, "publish");
        this._data = _.extend({}, CHANGE_DATA);
    });

    afterEach(() => {
        this._appPublish.restore();
    });

    describe("with data", () => {
        beforeEach(() => {
            this._sv = stubStoreVal({  action: ADDED });
            domainUpdate(this._sv, this._data);
        });

        it("should call set on the store value", () => {
            this._sv.set.should.have.been.calledWith(sinon.match(this._data));
        });

        it("should have published a change", () => {
            App.events.publish.should.have.been.called;
        });

        it("should have published a change with the new data", () => {
            App.events.publish.getCall(0).args[1].data.should.eql(this._data);
        });
    });

    describe("with data that causes no store value change", () => {
        beforeEach(() => {
            this._sv = stubStoreVal({  action: NONE });
            domainUpdate(this._sv, this._data);
        });

        it("should NOT have published a change", () => {
            App.events.publish.should.not.have.been.called;
        });
    });

    describe("with updated data", () => {
        beforeEach(() => {
            this._prev = { color: "red" };
            this._sv = stubStoreVal({ 
                action: MODIFIED,
                previousValue: this._prev
            });
        });
        describe("without providing new fields", () => {
            beforeEach(() => {
                domainUpdate(this._sv, this._data);
            });

            it("should have published a change", () => {
                App.events.publish.should.have.been.called;
            });

            it("should have published a change with the previous value", () => {
                App.events.publish.getCall(0).args[1].previous.should.equal(this._prev);
            });

            // Ensure we only send NEW VALUES!
            // We pass more properties to `domainUpdate` than we need to.
            //    { name: "bob", color: "blue", size: 100 }
            // but the previousValue only comes back with a different color.
            // so store must already had the name bob and size 100.
            it("should have published a change with the previous value", () => {
                App.events.publish.getCall(0).args[1].data.should.eql({
                    color: "blue"
                });
            });
        });

        describe("without providing new fields", () => {
            beforeEach(() => {
                this._data.isValid = true; // New property for the store value.
                domainUpdate(this._sv, this._data);
            });

            // Ensure we only send NEW VALUES includes fields that are NEW!
            it("should have published a change with the previous value", () => {
                App.events.publish.getCall(0).args[1].data.should.eql({
                    color: "blue",
                    isValid: true
                });
            });
        });
    });
});
