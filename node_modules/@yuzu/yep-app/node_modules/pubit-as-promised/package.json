{
  "name": "pubit-as-promised",
  "description": "Responsible publish/subscribe now enhanced with Q promise goodness! Hide the event publisher, only exposing the event emitter.",
  "keywords": [
    "pubsub",
    "pub/sub",
    "eventemitter",
    "events",
    "promise",
    "wildcard"
  ],
  "version": "1.1.2",
  "author": {
    "name": "YuzuJS"
  },
  "contributors": [
    {
      "name": "Domenic Denicola",
      "email": "domenic@domenicdenicola.com",
      "url": "http://domenicdenicola.com"
    },
    {
      "name": "Donavon West",
      "email": "github@donavon.com",
      "url": "http://donavon.com"
    },
    {
      "name": "Paul Bouzakis",
      "email": "github@paulbouzakis.com",
      "url": "http://paulbouzakis.com"
    }
  ],
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/YuzuJS/pubit-as-promised.git"
  },
  "bugs": {
    "url": "http://github.com/YuzuJS/pubit-as-promised/issues"
  },
  "directories": {
    "lib": "./lib",
    "test": "test"
  },
  "main": "./lib/pubit-as-promised.js",
  "scripts": {
    "test": "mocha",
    "lint": "jshint --show-non-errors lib"
  },
  "engines": {
    "node": "*"
  },
  "dependencies": {
    "dict": "1.3 - 1",
    "q": "0.8.12 - 1"
  },
  "devDependencies": {
    "jshint": ">= 0.7.1",
    "coffee-script": ">= 1.3.3",
    "mocha": ">= 1.1.0",
    "chai": ">= 1.0.4",
    "sinon": ">= 1.3.4",
    "sinon-chai": ">= 2.1.0"
  },
  "readme": "Pubit-as-promised [![Build Status](https://travis-ci.org/YuzuJS/pubit-as-promised.svg)](https://travis-ci.org/YuzuJS/pubit-as-promised)\r\n=====\r\nResponsible publish/subscribe. Hide the event publisher, only exposing the event emitter.\r\nNow with added Q promise goodness! Now, now you can listen to wildcard event names!\r\n\r\n\r\nWhy is this cool?\r\n-----------------\r\n\r\nMost pub/sub frameworks conflate the role of publisher and emitter. This means that if someone gets ahold of your \r\nemitter object, they can not only subscribe to events, but also fake out all other subscribers by emitting an \r\nartificial event:\r\n\r\n```javascript\r\n\r\n// server.js\r\nprocess.on(\"exit\", cleanupServerStuff);\r\n\r\n// thirdParty.js\r\nprocess.emit(\"exit\");\r\n// uh oh, now the server stuff's been all cleaned up!\r\n```\r\n\r\nWith **pubit-as-promised**, the publisher and emitter are separate, allowing you to keep the publisher private while\r\nexposing emitter functionality. Here's a hypothetical implementation of a `process` module using pubit-as-promised, \r\nincluding the use of the new Q promise return value of `publish`:\r\n\r\n```javascript\r\nvar pubit = require(\"pubit-as-promised\");\r\n\r\nvar publish = pubit.makeEmitter(exports);\r\n\r\nexports.exit = function (exitCode) {\r\n  publish.when(\"exit\", exitCode).done(function () {\r\n    window.close();\r\n  });\r\n};\r\n```\r\n\r\nAn example of a subscriber that returns a promise looks like this:\r\n\r\n```javascript\r\nvar process = require(\"./process\");\r\n\r\nprocess.on(\"exit\", function () {\r\n  return sendLogsToCloudAsync();\r\n});\r\n```\r\n\r\nThis module only exports the emitter interface (`on`, `off`, and `once`); the publish function is kept private.\r\n\r\n\r\nAren't you being paranoid?\r\n--------------------------\r\n\r\nThere's [some argument][1] as to what role encapsulation has to play in JavaScript. Some might say, “if you don't \r\nwant the event to be emitted outside the emitter … don't emit the event outside the emitter.”\r\n\r\nBut encapsulation isn't about being paranoid. It's about _hiding complexity_: exposing a solution, without requiring \r\nthe consumer to grok the gory details of the problem. An emitter by itself is simple and easy to interface with, \r\nbut when you add knobs for publishing or introspection, you're no longer solving a problem, but instead creating \r\noption paralysis and fragility. Someone should be able to understand that an object emits events, without worrying \r\nabout who could be publishing those events in the first place.\r\n\r\nPubit-as-promised is [ポカヨケ][2].\r\n\r\n\r\nPromises and Pub/Sub?\r\n---------------------\r\n\r\nSure. Why not? One of the deficiencies in the original pubit was the inability to return a value. It was a true \r\npublish only system. With pubit-as-promised you now have the ability for subscribers to asynchronously\r\nreturn values to the publisher. Think of the possibilities. Imagine a system where a publisher send out a \r\nlunch order and subscribers could return what they wanted to eat. The order would be places when all \r\nsubscribers  answered (i.e. fulfilled their promise).\r\n\r\nAnother example (show below) is a voting system. The publisher sends out a list of candidates, then waits \r\nfor each vote to be fulfilled (again a promise). The publisher then tallies the votes and publishes\r\nthe winner. The sample code is shown here:\r\n\r\n```javascript\r\n// The publisher.\r\npublish.when(\"vote\", candidates).done(function(votes) {\r\n    var winner = tallyVotes(votes);\r\n    publish(\"winner\", winner);\r\n});\r\n\r\n// Each subscriber.\r\nvoter.on(\"vote\", function(candidates) {\r\n    var deferred = Q.defer();\r\n \r\n    voter.once(\"winner\", displayWinner);\r\n \r\n    function onsubmit(myChoice) {\r\n        deferred.resolve(myChoice);\r\n    }\r\n \r\n    setupForm(onSubmit, candidates);\r\n    return deferred.promise;\r\n});\r\n```\r\n\r\nWildcard and RegExp Events\r\n--------------------------\r\n\r\nThere is a new method called `onMatch` that you can use to listen to multiple events.\r\nThis is especially useful for setuping up a single logger.\r\nThe pattern may be a string with a wildcard (i.e. \"*\") or a Regular Expression.\r\nSee the [API reference][5] for further details.\r\n\r\n```javascript\r\n// Log every event.\r\nvar unsubscribe = emitter.onMatch(\"ui.*\", function (eventName) {\r\n  console.log(\"%s Event %s was published\", new Date().toISOString(), eventName);\r\n})\r\n\r\npublish(\"ui.list.add\"); // This will be logged above.\r\npublish(\"ui.session.signin\"); // This will not.\r\n\r\n// And when you no longer want to listen, simply call the returned unsubscribe function.\r\nunsubscribe();\r\n```\r\n\r\nMore docs and examples\r\n----------------------\r\n\r\n* Check out [a simple example][3] of using pubit-as-promised for responsible pub/sub.\r\n* Be sure to check out the [listener helper examples][4] to get a look at a nice feature pubit-as-promised provides \r\nto solve a common use case.\r\n* If you like that sort of thing, we also have an [API reference][5].\r\n* Perhaps most educational would be checking out [the unit tests][6]—they're very readable, I promise! \r\nRun them with `npm test` if you'd like.\r\n\r\n\r\n\r\n[1]: https://mail.mozilla.org/pipermail/es-discuss/2011-November/017872.html\r\n[2]: http://blog.ploeh.dk/2011/05/24/PokayokeDesignFromSmellToFragrance.aspx\r\n[3]: https://github.com/NobleJS/pubit-as-promised/wiki/Simple-Example\r\n[4]: https://github.com/NobleJS/pubit-as-promised/wiki/Listener-Helper-Examples\r\n[5]: https://github.com/NobleJS/pubit-as-promised/wiki/API-Reference\r\n[6]: https://github.com/NobleJS/pubit-as-promised/tree/master/test\r\n",
  "readmeFilename": "README.md",
  "homepage": "https://github.com/YuzuJS/pubit-as-promised",
  "_id": "pubit-as-promised@1.1.2",
  "_from": "pubit-as-promised@>=1.1.2 <2.0.0"
}
